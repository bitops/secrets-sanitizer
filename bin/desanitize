#!/usr/bin/env ruby

# Copyright (C) 2016-Present Pivotal Software, Inc. All rights reserved.
#
# This program and the accompanying materials are made available under
# the terms of the under the Apache License, Version 2.0 (the "License”);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.Copyright (C) 2016-Present Pivotal Software, Inc. # All rights reserved.
#
# This program and the accompanying materials are made available under
# the terms of the under the Apache License, Version 2.0 (the "License”);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.#!/bin/sh


lib = File.expand_path('../../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'optparse'
require 'desanitizer'
require 'yaml'
require 'logger'

def help exitcode=0
  puts "Desantize will take secrets and place them into a previously sanitized environment"
  puts
  puts "#{$0} [options]"
  puts "-h, --help          Help. See this help message."
  puts "-i, --input         Input manifest file or directory"
  puts "-s, --secret-dir    Folder where all secrets will be read"
  puts "-f  --force         Desanitize files even if files with secrets do not have a matching secret files"
  puts "-v, --verbose"
  puts "-m, --manifest      [deprecated] Input manifest file"
  puts "-d, --input-dir     [deprecated] Input Directory containing yaml with secrets"
  exit exitcode
end

if ARGV.empty?
  help 1
end

options = {}
OptionParser.new do |opts|
  options[:input] = []
  opts.banner = "Usage: #{$0} [options]"

  opts.on("-h", "--help", "Help") do
    help
  end

  opts.on("-iINPUT", "--input=INPUT", "Input file or directory") do |option|
    options[:input] << option
  end

  opts.on("-sSECRETDIR", "--secret-dir=SECRETDIR", "Secret file directory") do |option|
    options[:sec_dir] = option
  end

  opts.on("-mMANIFEST", "--manifest=MANIFEST", "Manifest yaml") do |option|
    # options[:manifest] = option
    options[:input] << option
  end

  opts.on("-dINPUT_DIR", "--input-dir=INPUTDIR", "Input directory of yaml files") do |option|
    # options[:input_dir] = option
    options[:input] << option
  end

  opts.on("-v", "--verbose") do
    options[:verbose] = true
  end

  opts.on("-f", "--force", "Attempt to Desanitize even if secret file(s) not present") do
    options[:force] = true
  end
end.parse!

errors = []
if options[:input].count > 1
  errors << "Only specify one input manifest/directory!"
end

if options[:sec_dir].nil?
  errors << "Output secrets directory is required."
end

if options[:input].empty?
  errors << "Manifest or input directory is required."
end


unless errors.empty?
  errors.each do |error|
    $stderr.puts "ERROR: #{error}"
  end
  exit 1
end


logger = Logger.new(STDERR)
if options[:verbose]
  logger.level = Logger::DEBUG
else
  logger.level = Logger::ERROR
end

if File.file?(options[:input][0]) && !File.lstat(options[:input][0]).symlink?
  # it's a file!
  logger.warn "Desanitizing file #{options[:input][0]}..."
  Desanitizer::DesanitizeExecutor.execute(options[:input][0], options[:sec_dir], logger, options[:force])
elsif File.lstat(options[:input][0]).symlink?
  logger.warn("Resolving symlink #{options[:input][0]} to #{File.readlink(options[:input][0])}")
  Desanitizer::DesanitizeExecutor.execute(File.readlink(options[:input][0]), options[:sec_dir], logger, options[:force])
else
  # do directory
  Dir.glob(File.join(options[:input][0], '**', '*.yml')) do |this_file|
    if File.lstat(this_file).symlink?
      logger.warn "Skipping file #{this_file} because symlinks are skipped in directory mode"
    else
      logger.warn "Desanitizing file #{this_file}..."
      Desanitizer::DesanitizeExecutor.execute(this_file, options[:sec_dir], logger, options[:force])
    end
  end
end

