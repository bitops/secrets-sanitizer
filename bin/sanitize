#!/usr/bin/env ruby
lib = File.expand_path('../../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'optparse'
require 'sanitizer'
require 'yaml'

def help exitcode=0
  puts "#{$0} [options]"
  puts "-h, --help Help. See this help message."
  puts "-m, --manifest= Manifest file"
  puts "-d, --input-dir= Input Directory containing yaml with secrets"
  puts "-p, --pattern-file= Pattern file containing secret patterns"
  puts "-s, --secret-dir= Output folder where all secrets will be written"
  exit exitcode
end

if ARGV.empty?
  help 1
end

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.on("-h", "--help", "Help") do |h|
    help
  end

  opts.on("-sSECRETDIR", "--secret-dir=SECRETDIR", "Secret file directory") do |s|
    options[:sec_dir] = s
  end

  opts.on("-pPATTERNFILE", "--pattern-file=PATTERNFILE", "File with regex patterns to match secret keys") do |p|
    options[:pattern_file] = p
  end

  opts.on("-mMANIFEST", "--manifest=MANIFEST", "Manifest yaml") do |m|
    options[:manifest] = m
  end

  opts.on("-dINPUT_DIR", "--input-dir=INPUTDIR", "Input directory of yaml files") do |i|
    options[:input_dir] = i
  end
end.parse!


# check arguments
errors = []

if options[:sec_dir].nil?
  errors << "Output secrets directory is required."
end

if options[:pattern_file].nil?
  errors << "Pattern file is required."
end

if options[:manifest].nil? and options[:input_dir].nil?
  errors << "Manifest or input directory is required."
end

unless errors.empty?
  errors.each do |error|
    $stderr.puts "ERROR: #{error}"
  end
  exit 1
end


# start sanitizing
unless options[:manifest].nil?
  # it's a file
  Sanitizer::SanitizeExecutor.execute(options[:manifest], options[:pattern_file], options[:sec_dir])
else
  # it's a directory
  Dir.glob(File.join(options[:input_dir], '**', '*.yml')) do |f|
    $stderr.puts "Sanitizing file #{f}..."
    Sanitizer::SanitizeExecutor.execute(f, options[:pattern_file], options[:sec_dir])
  end
end

