#!/usr/bin/env ruby
lib = File.expand_path('../../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'optparse'
require 'sanitizer'
require 'yaml'

default_pattern_file = File.expand_path(File.join(File.dirname(__FILE__), "../config/catchall"))

def help exitcode=0
  puts "#{$0} [options]"
  puts "-h, --help          Help. See this help message."
  puts "-i, --input         Input manifest file or directory"
  puts "-s, --secret-dir    Folder where all secrets will be written"
  puts "-p, --pattern-file  (optional) Pattern file containing secrets patterns"
  puts "                      config/catchall is used by default"
  puts "-m, --manifest      [deprecated] Input manifest file"
  puts "-d, --input-dir     [deprecated] Input Directory containing yaml with secrets"
  exit exitcode
end

if ARGV.empty?
  help 1
end

options = {}
OptionParser.new do |opts|
  options[:input] = []

  opts.banner = "Usage: #{$0} [options]"

  opts.on("-h", "--help", "Help") do |h|
    help
  end

  opts.on("-iINPUT", "--input=INPUT", "Input file or directory") do |option|
    options[:input] << option
  end

  opts.on("-sSECRETDIR", "--secret-dir=SECRETDIR", "Secret file directory") do |option|
    options[:sec_dir] = option
  end

  opts.on("-pPATTERNFILE", "--pattern-file=PATTERNFILE", "File with regex patterns to match secret keys") do |option|
    options[:pattern_file] = option
  end

  opts.on("-mMANIFEST", "--manifest=MANIFEST", "Manifest yaml") do |option|
    options[:input] << option
  end

  opts.on("-dINPUT_DIR", "--input-dir=INPUTDIR", "Input directory of yaml files") do |option|
    options[:input] << option
  end
end.parse!


# check arguments
errors = []

if options[:sec_dir].nil?
  errors << "Output secrets directory is required."
end

if options[:pattern_file].nil?
  options[:pattern_file] = default_pattern_file
end

if options[:input].empty?
  errors << "Manifest or input directory is required."
end

unless errors.empty?
  errors.each do |error|
    $stderr.puts "ERROR: #{error}"
  end
  exit 1
end

# start sanitizing
if File.file?(options[:input][0])
  # it's a file
  Sanitizer::SanitizeExecutor.execute(options[:input][0], options[:pattern_file], options[:sec_dir])
else
  # it's a directory
  Dir.glob(File.join(options[:input][0], '**', '*.yml')) do |manifest_path|
    Sanitizer::SanitizeExecutor.execute(manifest_path, options[:pattern_file], options[:sec_dir])
  end
end

